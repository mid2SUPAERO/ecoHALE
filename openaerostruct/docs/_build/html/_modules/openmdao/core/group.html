
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>openmdao.core.group &#8212; OpenMDAO 2.1.0 Alpha documentation</title>
    
    <link rel="stylesheet" href="../../../_static/style.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.1.0 Alpha',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../../../_static/OpenMDAO_Favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">OpenMDAO 2.1.0 Alpha documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../../index.html">
              <img class="logo" src="../../../_static/OpenMDAO_Logo.png" alt="Logo"/>
            </a></p>
<h3><a href="../../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started/index.html">Getting Started</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../_srcdocs/index.html">Source Docs</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for openmdao.core.group</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Define the Group class.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span><span class="p">,</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Number</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">six</span> <span class="k">import</span> <span class="n">iteritems</span><span class="p">,</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">itervalues</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">range</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

<span class="kn">from</span> <span class="nn">openmdao.approximation_schemes.complex_step</span> <span class="k">import</span> <span class="n">ComplexStep</span>
<span class="kn">from</span> <span class="nn">openmdao.approximation_schemes.finite_difference</span> <span class="k">import</span> <span class="n">FiniteDifference</span>
<span class="kn">from</span> <span class="nn">openmdao.core.system</span> <span class="k">import</span> <span class="n">System</span>
<span class="kn">from</span> <span class="nn">openmdao.core.component</span> <span class="k">import</span> <span class="n">Component</span>
<span class="kn">from</span> <span class="nn">openmdao.proc_allocators.default_allocator</span> <span class="k">import</span> <span class="n">DefaultAllocator</span><span class="p">,</span> <span class="n">ProcAllocationError</span>
<span class="kn">from</span> <span class="nn">openmdao.jacobians.assembled_jacobian</span> <span class="k">import</span> <span class="n">SUBJAC_META_DEFAULTS</span>
<span class="kn">from</span> <span class="nn">openmdao.recorders.recording_iteration_stack</span> <span class="k">import</span> <span class="n">Recording</span>
<span class="kn">from</span> <span class="nn">openmdao.solvers.nonlinear.nonlinear_runonce</span> <span class="k">import</span> <span class="n">NonlinearRunOnce</span>
<span class="kn">from</span> <span class="nn">openmdao.solvers.linear.linear_runonce</span> <span class="k">import</span> <span class="n">LinearRunOnce</span>
<span class="kn">from</span> <span class="nn">openmdao.utils.array_utils</span> <span class="k">import</span> <span class="n">convert_neg</span>
<span class="kn">from</span> <span class="nn">openmdao.utils.general_utils</span> <span class="k">import</span> <span class="n">warn_deprecation</span><span class="p">,</span> <span class="n">ContainsAll</span><span class="p">,</span> <span class="n">all_ancestors</span>
<span class="kn">from</span> <span class="nn">openmdao.utils.units</span> <span class="k">import</span> <span class="n">is_compatible</span>
<span class="kn">from</span> <span class="nn">openmdao.utils.mpi</span> <span class="k">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">openmdao.utils.graph_utils</span> <span class="k">import</span> <span class="n">all_connected_nodes</span>

<span class="c1"># regex to check for valid names.</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">namecheck_rgx</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;[a-zA-Z][_a-zA-Z0-9]*&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">System</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used to group systems together; instantiate or inherit.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _mpi_proc_allocator : ProcAllocator</span>
<span class="sd">        Object used to allocate MPI processes to subsystems.</span>
<span class="sd">    _proc_info : dict of subsys_name: (min_procs, max_procs, weight)</span>
<span class="sd">        Information used to determine MPI process allocation to subsystems.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the solvers to nonlinear and linear block Gauss--Seidel by default.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            dict of arguments available here and in all descendants of this</span>
<span class="sd">            Group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># TODO: we cannot set the solvers with property setters at the moment</span>
        <span class="c1"># because our lint check thinks that we are defining new attributes</span>
        <span class="c1"># called nonlinear_solver and linear_solver without documenting them.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_solver</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_solver</span> <span class="o">=</span> <span class="n">NonlinearRunOnce</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_solver</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linear_solver</span> <span class="o">=</span> <span class="n">LinearRunOnce</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mpi_proc_allocator</span> <span class="o">=</span> <span class="n">DefaultAllocator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_proc_info</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build this group.</span>

<span class="sd">        This method should be overidden by your Group&#39;s method.</span>

<span class="sd">        You may call &#39;add_subsystem&#39; to add systems to this group. You may also issue connections,</span>
<span class="sd">        and set the linear and nonlinear solvers for this group level. You cannot safely change</span>
<span class="sd">        anything on children systems; use the &#39;configure&#39; method instead.</span>

<span class="sd">        Available attributes:</span>
<span class="sd">            name</span>
<span class="sd">            pathname</span>
<span class="sd">            comm</span>
<span class="sd">            metadata</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure this group to assign children settings.</span>

<span class="sd">        This method may optionally be overidden by your Group&#39;s method.</span>

<span class="sd">        You may only use this method to change settings on your children subsystems. This includes</span>
<span class="sd">        setting solvers in cases where you want to override the defaults.</span>

<span class="sd">        You can assume that the full hierarchy below your level has been instantiated and has</span>
<span class="sd">        already called its own configure methods.</span>

<span class="sd">        Available attributes:</span>
<span class="sd">            name</span>
<span class="sd">            pathname</span>
<span class="sd">            comm</span>
<span class="sd">            metadata</span>
<span class="sd">            system hieararchy with attribute access</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_configure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Configure our model recursively to assign any children settings.</span>

<span class="sd">        Highest system&#39;s settings take precedence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
            <span class="n">subsys</span><span class="o">.</span><span class="n">_configure</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_has_guess</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_guess</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">configure</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_procs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pathname</span><span class="p">,</span> <span class="n">comm</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Distribute processors and assign pathnames.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        pathname : str</span>
<span class="sd">            Global name of the system, including the path.</span>
<span class="sd">        comm : MPI.Comm or &lt;FakeComm&gt;</span>
<span class="sd">            MPI communicator object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="o">=</span> <span class="n">pathname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">comm</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_manual_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_design_vars</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_responses</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_static_mode</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_subsystems_allprocs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_manual_connections</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_manual_connections</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_design_vars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_design_vars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_responses</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_static_responses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_static_mode</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">MPI</span><span class="p">:</span>
            <span class="n">proc_info</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_proc_info</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">]</span>

            <span class="c1"># Call the load balancing algorithm</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sub_inds</span><span class="p">,</span> <span class="n">sub_comm</span><span class="p">,</span> <span class="n">sub_proc_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mpi_proc_allocator</span><span class="p">(</span>
                    <span class="n">proc_info</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">),</span> <span class="n">comm</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ProcAllocationError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">subs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span>
                <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">sub_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">msg</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: MPI process allocation failed: </span><span class="si">%s</span><span class="s2"> for the following &quot;</span>
                                       <span class="s2">&quot;subsystems: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span>
                                                           <span class="p">[</span><span class="n">subs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">err</span><span class="o">.</span><span class="n">sub_inds</span><span class="p">]))</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">sub_inds</span><span class="p">]</span>

            <span class="c1"># Define local subsystems</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">minp</span> <span class="k">for</span> <span class="n">minp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">proc_info</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc_inds</span> <span class="o">=</span> <span class="n">sub_inds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># reorder the subsystems_allprocs based on which procs they live on. If we don&#39;t</span>
                <span class="c1"># do this, we can get ordering mismatches in some of our data structures.</span>
                <span class="n">new_allsubs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">gathered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">sub_inds</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">rank</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gathered</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">inds</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">ind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                            <span class="n">new_allsubs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span> <span class="o">=</span> <span class="n">new_allsubs</span>
                <span class="n">sub_idxs</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">)}</span>

                <span class="c1"># since the subsystems_allprocs order changed, we also have to update</span>
                <span class="c1"># subsystems_myproc_inds</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc_inds</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_idxs</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sub_comm</span> <span class="o">=</span> <span class="n">comm</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">)))</span>
            <span class="n">sub_proc_range</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Compute _subsystems_proc_range</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_proc_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">sub_proc_range</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">)</span>

        <span class="c1"># Perform recursion</span>
        <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_procs</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">)),</span> <span class="n">sub_comm</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_procs</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">sub_comm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call setup in components and count variables, total and by var_set.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_vars</span><span class="p">()</span>
        <span class="n">num_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var</span>
        <span class="n">num_var_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span>

        <span class="c1"># Recursion</span>
        <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_vars</span><span class="p">(</span><span class="n">recurse</span><span class="p">)</span>

        <span class="c1"># Compute num_var, num_var_byset, at least locally</span>
        <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_rel_vec_name_list</span><span class="p">:</span>
            <span class="n">num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                <span class="n">num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">subsys</span><span class="o">.</span><span class="n">_num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span>
                     <span class="k">if</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_rel_vec_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

                <span class="n">num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="n">vbyset</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">vec_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_rel_vec_names</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">set_name</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]):</span>
                        <span class="k">if</span> <span class="n">set_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vbyset</span><span class="p">:</span>
                            <span class="n">vbyset</span><span class="p">[</span><span class="n">set_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">vbyset</span><span class="p">[</span><span class="n">set_name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num</span>

        <span class="c1"># If running in parallel, allgather</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Perform a single allgather</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_var</span><span class="p">,</span> <span class="n">num_var_byset</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">gathered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_rel_vec_name_list</span><span class="p">:</span>
                <span class="n">num_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>
                <span class="n">num_var_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>

                <span class="c1"># Empty the dictionaries</span>
                <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                    <span class="n">num_var</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">num_var_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="c1"># Process the gathered data and update the dictionaries</span>
                <span class="k">for</span> <span class="n">myproc_num_var</span><span class="p">,</span> <span class="n">myproc_num_var_byset</span> <span class="ow">in</span> <span class="n">gathered</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">myproc_num_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                        <span class="n">num_var</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">+=</span> <span class="n">myproc_num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">set_name</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">myproc_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]):</span>
                            <span class="k">if</span> <span class="n">set_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">num_var_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">]:</span>
                                <span class="n">num_var_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="n">num_var_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span> <span class="o">+=</span> <span class="n">num</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_num_var</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_setup_var_index_ranges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">set2iset</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the division of variables by subsystem and pass down the set_name-to-iset maps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        set2iset : {&#39;input&#39;: dict, &#39;output&#39;: dict}</span>
<span class="sd">            Dictionary mapping the var_set name to the var_set index.</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_var_index_ranges</span><span class="p">(</span><span class="n">set2iset</span><span class="p">)</span>

        <span class="n">nsub_allprocs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">)</span>

        <span class="n">subsystems_var_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_var_range</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">subsystems_var_range_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_var_range_byset</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># First compute these on one processor for each subsystem</span>
        <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_rel_vec_name_list</span><span class="p">:</span>

            <span class="c1"># Here, we count the number of variables (total and by varset) in each subsystem.</span>
            <span class="c1"># We do this so that we can compute the offset when we recurse into each subsystem.</span>
            <span class="n">allprocs_counters</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">type_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]}</span>
            <span class="n">allprocs_counters_byset</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">type_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsub_allprocs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">set2iset</span><span class="p">[</span><span class="n">type_</span><span class="p">])),</span> <span class="nb">int</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]}</span>

            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">subsys</span><span class="p">,</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc_inds</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">subsys</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_rel_vec_names</span><span class="p">:</span>
                        <span class="n">allprocs_counters</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">isub</span><span class="p">]</span> <span class="o">=</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">set_name</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]:</span>
                            <span class="n">iset</span> <span class="o">=</span> <span class="n">set2iset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span>
                            <span class="n">allprocs_counters_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">isub</span><span class="p">,</span> <span class="n">iset</span><span class="p">]</span> <span class="o">=</span> \
                                <span class="n">subsys</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span>

            <span class="c1"># If running in parallel, allgather</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">allprocs_counters</span><span class="p">,</span> <span class="n">allprocs_counters_byset</span><span class="p">)</span>
                <span class="n">gathered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>

                <span class="n">allprocs_counters</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">type_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]}</span>
                <span class="n">allprocs_counters_byset</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">type_</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nsub_allprocs</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">set2iset</span><span class="p">[</span><span class="n">type_</span><span class="p">])),</span> <span class="nb">int</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]</span>
                <span class="p">}</span>
                <span class="k">for</span> <span class="n">myproc_counters</span><span class="p">,</span> <span class="n">myproc_counters_byset</span> <span class="ow">in</span> <span class="n">gathered</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                        <span class="n">allprocs_counters</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">+=</span> <span class="n">myproc_counters</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span>
                        <span class="n">allprocs_counters_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">+=</span> <span class="n">myproc_counters_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span>

            <span class="c1"># Compute _subsystems_var_range, _subsystems_var_range_byset</span>
            <span class="n">subsystems_var_range</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">subsystems_var_range_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                <span class="n">subsystems_var_range</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">subsystems_var_range_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">set_name</span><span class="p">:</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">set_name</span> <span class="ow">in</span> <span class="n">set2iset</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span>
                <span class="p">}</span>

                <span class="k">for</span> <span class="n">subsys</span><span class="p">,</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc_inds</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">vec_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_rel_vec_names</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">subsystems_var_range</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">allprocs_counters</span><span class="p">[</span><span class="n">type_</span><span class="p">][:</span><span class="n">isub</span><span class="p">]),</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">allprocs_counters</span><span class="p">[</span><span class="n">type_</span><span class="p">][:</span><span class="n">isub</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="k">for</span> <span class="n">set_name</span><span class="p">,</span> <span class="n">rng</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">subsystems_var_range_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]):</span>
                        <span class="n">iset</span> <span class="o">=</span> <span class="n">set2iset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span>
                        <span class="n">rng</span><span class="p">[</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">allprocs_counters_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][:</span><span class="n">isub</span><span class="p">,</span> <span class="n">iset</span><span class="p">]),</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">allprocs_counters_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][:</span><span class="n">isub</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                                                  <span class="n">iset</span><span class="p">]))</span>

        <span class="n">subsystems_var_range</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subsystems_var_range</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>
        <span class="n">subsystems_var_range_byset</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">subsystems_var_range_byset</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>

        <span class="c1"># Recursion</span>
        <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_var_index_ranges</span><span class="p">(</span><span class="n">set2iset</span><span class="p">,</span> <span class="n">recurse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_var_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the list of abs var names, abs/prom name maps, and metadata dictionaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_var_data</span><span class="p">()</span>
        <span class="n">allprocs_abs_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs_names</span>
        <span class="n">abs_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs_names</span>
        <span class="n">allprocs_prom2abs_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_prom2abs_list</span>
        <span class="n">abs2prom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs2prom</span>
        <span class="n">allprocs_abs2meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs2meta</span>
        <span class="n">abs2meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs2meta</span>

        <span class="c1"># Recursion</span>
        <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_var_data</span><span class="p">(</span><span class="n">recurse</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_output_scaling</span> <span class="o">|=</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_has_output_scaling</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_resid_scaling</span> <span class="o">|=</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_has_resid_scaling</span>

        <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
            <span class="n">var_maps</span> <span class="o">=</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_get_maps</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_var_allprocs_prom2abs_list</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>

                <span class="c1"># Assemble abs_names and allprocs_abs_names</span>
                <span class="n">allprocs_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_var_allprocs_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">])</span>
                <span class="n">abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_var_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">])</span>

                <span class="c1"># Assemble allprocs_abs2meta and abs2meta</span>
                <span class="n">allprocs_abs2meta</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_var_allprocs_abs2meta</span><span class="p">[</span><span class="n">type_</span><span class="p">])</span>
                <span class="n">abs2meta</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_var_abs2meta</span><span class="p">[</span><span class="n">type_</span><span class="p">])</span>

                <span class="c1"># Assemble abs2prom</span>
                <span class="k">for</span> <span class="n">abs_name</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_var_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">]:</span>
                    <span class="n">sub_prom_name</span> <span class="o">=</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_var_abs2prom</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">abs_name</span><span class="p">]</span>
                    <span class="n">abs2prom</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">abs_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_maps</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">sub_prom_name</span><span class="p">]</span>

                <span class="c1"># Assemble allprocs_prom2abs_list</span>
                <span class="n">sub_allprocs_prom2abs_list_t</span> <span class="o">=</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_var_allprocs_prom2abs_list</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">sub_prom_name</span> <span class="ow">in</span> <span class="n">sub_allprocs_prom2abs_list_t</span><span class="p">:</span>
                    <span class="n">prom_name</span> <span class="o">=</span> <span class="n">var_maps</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">sub_prom_name</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">prom_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allprocs_prom2abs_list</span><span class="p">[</span><span class="n">type_</span><span class="p">]:</span>
                        <span class="n">allprocs_prom2abs_list</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">prom_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">allprocs_prom2abs_list</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">prom_name</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="n">sub_allprocs_prom2abs_list_t</span><span class="p">[</span><span class="n">sub_prom_name</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">prom_name</span><span class="p">,</span> <span class="n">abs_list</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">allprocs_prom2abs_list</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">abs_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Output name &#39;</span><span class="si">%s</span><span class="s2">&#39; refers to &quot;</span>
                                   <span class="s2">&quot;multiple outputs: </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="n">prom_name</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">abs_list</span><span class="p">)))</span>

        <span class="c1"># If running in parallel, allgather</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="p">(</span><span class="n">allprocs_abs_names</span><span class="p">,</span> <span class="n">allprocs_prom2abs_list</span><span class="p">,</span> <span class="n">allprocs_abs2meta</span><span class="p">,</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_has_output_scaling</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_resid_scaling</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">{</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="p">[]},</span>
                    <span class="p">{</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="p">{}},</span>
                    <span class="p">{</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="p">{}},</span>
                    <span class="kc">False</span><span class="p">,</span>
                    <span class="kc">False</span>
                <span class="p">)</span>
            <span class="n">gathered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                <span class="n">allprocs_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">allprocs_prom2abs_list</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">myproc_abs_names</span><span class="p">,</span> <span class="n">myproc_prom2abs_list</span><span class="p">,</span> <span class="n">myproc_abs2meta</span><span class="p">,</span> <span class="n">oscale</span><span class="p">,</span> <span class="n">rscale</span> <span class="ow">in</span> <span class="n">gathered</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_output_scaling</span> <span class="o">|=</span> <span class="n">oscale</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_has_resid_scaling</span> <span class="o">|=</span> <span class="n">rscale</span>

                <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>

                    <span class="c1"># Assemble in parallel allprocs_abs_names</span>
                    <span class="n">allprocs_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">myproc_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">])</span>

                    <span class="c1"># Assemble in parallel allprocs_abs2meta</span>
                    <span class="n">allprocs_abs2meta</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">myproc_abs2meta</span><span class="p">[</span><span class="n">type_</span><span class="p">])</span>

                    <span class="c1"># Assemble in parallel allprocs_prom2abs_list</span>
                    <span class="k">for</span> <span class="n">prom_name</span><span class="p">,</span> <span class="n">abs_names_list</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">myproc_prom2abs_list</span><span class="p">[</span><span class="n">type_</span><span class="p">]):</span>
                        <span class="n">allprocs_prom2abs_list</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">prom_name</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">abs_names_list</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_var_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the arrays of local variable sizes for all variables/procs on this system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_var_sizes</span><span class="p">()</span>

        <span class="n">iproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span>
        <span class="n">nproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span>

        <span class="n">subsystems_proc_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_proc_range</span>

        <span class="c1"># Recursion</span>
        <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_var_sizes</span><span class="p">(</span><span class="n">recurse</span><span class="p">)</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes</span>
        <span class="n">sizes_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes_byset</span>

        <span class="c1"># Compute _var_sizes</span>
        <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_rel_vec_name_list</span><span class="p">:</span>
            <span class="n">sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">subsystems_var_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_var_range</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>
            <span class="n">subsystems_var_range_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_var_range_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                <span class="n">sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nproc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]),</span> <span class="nb">int</span><span class="p">)</span>

                <span class="n">sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">set_name</span><span class="p">,</span> <span class="n">nvars</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]):</span>
                    <span class="n">sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nproc</span><span class="p">,</span> <span class="n">nvars</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">vec_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_rel_vec_names</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">proc_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">subsystems_proc_range</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
                    <span class="n">var_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">subsystems_var_range</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
                    <span class="n">sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">proc_slice</span><span class="p">,</span> <span class="n">var_slice</span><span class="p">]</span> <span class="o">=</span> \
                        <span class="n">subsys</span><span class="o">.</span><span class="n">_var_sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span>

                    <span class="k">for</span> <span class="n">set_name</span><span class="p">,</span> <span class="n">subsizes</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_var_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]):</span>
                        <span class="n">var_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="o">*</span><span class="n">subsystems_var_range_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
                        <span class="n">sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="n">proc_slice</span><span class="p">,</span> <span class="n">var_slice</span><span class="p">]</span> <span class="o">=</span> <span class="n">subsizes</span>

        <span class="c1"># If parallel, all gather</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_rel_vec_name_list</span><span class="p">:</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>
                <span class="n">sizes_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:],</span> <span class="n">sizes</span><span class="p">[</span><span class="n">type_</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">set_name</span><span class="p">,</span> <span class="n">vsizes</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">sizes_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">]):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">Allgather</span><span class="p">(</span><span class="n">sizes_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:],</span> <span class="n">vsizes</span><span class="p">)</span>

            <span class="c1"># compute owning ranks</span>
            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_owning_rank</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="n">owns</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">rank</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">sizes</span><span class="p">[</span><span class="n">rank</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">owns</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">rank</span>
                            <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes_byset</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes_byset</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_global_shapes</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_setup_global_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">conns</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute dict of all connections between this system&#39;s inputs and outputs.</span>

<span class="sd">        The connections come from 4 sources:</span>
<span class="sd">        1. Implicit connections owned by the current system</span>
<span class="sd">        2. Explicit connections declared by the current system</span>
<span class="sd">        3. Explicit connections declared by parent systems</span>
<span class="sd">        4. Implicit / explicit from subsystems</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        conns : dict</span>
<span class="sd">            Dictionary of connections passed down from parent group.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_global_connections</span><span class="p">()</span>

        <span class="n">global_abs_in2out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn_global_abs_in2out</span>

        <span class="n">allprocs_prom2abs_list_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_prom2abs_list</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
        <span class="n">allprocs_prom2abs_list_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_prom2abs_list</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
        <span class="n">abs2meta_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs2meta</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
        <span class="n">abs2meta_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs2meta</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
        <span class="n">pathname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span>

        <span class="n">abs_in2out</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">pathname</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">path_len</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">nparts</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">nparts</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pathname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span>

        <span class="n">new_conns</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">conns</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">abs_in</span><span class="p">,</span> <span class="n">abs_out</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">conns</span><span class="p">):</span>
                <span class="n">inparts</span> <span class="o">=</span> <span class="n">abs_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="n">outparts</span> <span class="o">=</span> <span class="n">abs_out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">inparts</span><span class="p">[:</span><span class="n">nparts</span><span class="p">]</span> <span class="o">==</span> <span class="n">outparts</span><span class="p">[:</span><span class="n">nparts</span><span class="p">]:</span>
                    <span class="n">global_abs_in2out</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_out</span>

                    <span class="c1"># if connection is contained in a subgroup, add to conns</span>
                    <span class="c1"># to pass down to subsystems.</span>
                    <span class="k">if</span> <span class="n">inparts</span><span class="p">[:</span><span class="n">nparts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">outparts</span><span class="p">[:</span><span class="n">nparts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">new_conns</span><span class="p">[</span><span class="n">inparts</span><span class="p">[</span><span class="n">nparts</span><span class="p">]][</span><span class="n">abs_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_out</span>

        <span class="c1"># Add implicit connections (only ones owned by this group)</span>
        <span class="k">for</span> <span class="n">prom_name</span> <span class="ow">in</span> <span class="n">allprocs_prom2abs_list_out</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prom_name</span> <span class="ow">in</span> <span class="n">allprocs_prom2abs_list_in</span><span class="p">:</span>
                <span class="n">abs_out</span> <span class="o">=</span> <span class="n">allprocs_prom2abs_list_out</span><span class="p">[</span><span class="n">prom_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">out_subsys</span> <span class="o">=</span> <span class="n">abs_out</span><span class="p">[</span><span class="n">path_len</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">abs_in</span> <span class="ow">in</span> <span class="n">allprocs_prom2abs_list_in</span><span class="p">[</span><span class="n">prom_name</span><span class="p">]:</span>
                    <span class="n">in_subsys</span> <span class="o">=</span> <span class="n">abs_in</span><span class="p">[</span><span class="n">path_len</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">out_subsys</span> <span class="o">!=</span> <span class="n">in_subsys</span><span class="p">:</span>
                        <span class="n">abs_in2out</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_out</span>

        <span class="c1"># Add explicit connections (only ones declared by this group)</span>
        <span class="k">for</span> <span class="n">prom_in</span><span class="p">,</span> <span class="p">(</span><span class="n">prom_out</span><span class="p">,</span> <span class="n">src_indices</span><span class="p">,</span> <span class="n">flat_src_indices</span><span class="p">)</span> <span class="ow">in</span> \
                <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_manual_connections</span><span class="p">):</span>

            <span class="c1"># throw an exception if either output or input doesn&#39;t exist</span>
            <span class="c1"># (not traceable to a connect statement, so provide context)</span>
            <span class="k">if</span> <span class="n">prom_out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allprocs_prom2abs_list_out</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="s2">&quot;Output &#39;</span><span class="si">%s</span><span class="s2">&#39; does not exist for connection in &#39;</span><span class="si">%s</span><span class="s2">&#39; from &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">prom_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">prom_out</span><span class="p">,</span> <span class="n">prom_in</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">prom_in</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allprocs_prom2abs_list_in</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span>
                    <span class="s2">&quot;Input &#39;</span><span class="si">%s</span><span class="s2">&#39; does not exist for connection in &#39;</span><span class="si">%s</span><span class="s2">&#39; from &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span>
                    <span class="p">(</span><span class="n">prom_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">prom_out</span><span class="p">,</span> <span class="n">prom_in</span><span class="p">))</span>

            <span class="c1"># Throw an exception if output and input are in the same system</span>
            <span class="c1"># (not traceable to a connect statement, so provide context)</span>
            <span class="c1"># and check if src_indices is defined in both connect and add_input.</span>
            <span class="n">abs_out</span> <span class="o">=</span> <span class="n">allprocs_prom2abs_list_out</span><span class="p">[</span><span class="n">prom_out</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">outparts</span> <span class="o">=</span> <span class="n">abs_out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
            <span class="n">out_subsys</span> <span class="o">=</span> <span class="n">outparts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">abs_in</span> <span class="ow">in</span> <span class="n">allprocs_prom2abs_list_in</span><span class="p">[</span><span class="n">prom_in</span><span class="p">]:</span>
                <span class="n">inparts</span> <span class="o">=</span> <span class="n">abs_in</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
                <span class="n">in_subsys</span> <span class="o">=</span> <span class="n">inparts</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">out_subsys</span> <span class="o">==</span> <span class="n">in_subsys</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Output and input are in the same System &quot;</span> <span class="o">+</span>
                                       <span class="s2">&quot;for connection in &#39;</span><span class="si">%s</span><span class="s2">&#39; from &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span>
                                       <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">prom_out</span><span class="p">,</span> <span class="n">prom_in</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">src_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">abs_in</span> <span class="ow">in</span> <span class="n">abs2meta_in</span><span class="p">:</span>
                    <span class="n">meta</span> <span class="o">=</span> <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;src_indices&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: src_indices has been defined &quot;</span>
                                           <span class="s2">&quot;in both connect(&#39;</span><span class="si">%s</span><span class="s2">&#39;, &#39;</span><span class="si">%s</span><span class="s2">&#39;) &quot;</span>
                                           <span class="s2">&quot;and add_input(&#39;</span><span class="si">%s</span><span class="s2">&#39;, ...).&quot;</span> <span class="o">%</span>
                                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="n">prom_out</span><span class="p">,</span>
                                            <span class="n">prom_in</span><span class="p">,</span> <span class="n">prom_in</span><span class="p">))</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;src_indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;flat_src_indices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flat_src_indices</span>

                <span class="k">if</span> <span class="n">abs_in</span> <span class="ow">in</span> <span class="n">abs_in2out</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Input &#39;</span><span class="si">%s</span><span class="s2">&#39; cannot be connected to &#39;</span><span class="si">%s</span><span class="s2">&#39; because it&#39;s already&quot;</span>
                                       <span class="s2">&quot; connected to &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">abs_in</span><span class="p">,</span> <span class="n">abs_out</span><span class="p">,</span> <span class="n">abs_in2out</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]))</span>

                <span class="n">abs_in2out</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_out</span>

                <span class="c1"># if connection is contained in a subgroup, add to conns to pass down to subsystems.</span>
                <span class="k">if</span> <span class="n">inparts</span><span class="p">[:</span><span class="n">nparts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">outparts</span><span class="p">[:</span><span class="n">nparts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="n">new_conns</span><span class="p">[</span><span class="n">inparts</span><span class="p">[</span><span class="n">nparts</span><span class="p">]][</span><span class="n">abs_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_out</span>

        <span class="c1"># Recursion</span>
        <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">subsys</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">new_conns</span><span class="p">:</span>
                    <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_global_connections</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="n">recurse</span><span class="p">,</span>
                                                     <span class="n">conns</span><span class="o">=</span><span class="n">new_conns</span><span class="p">[</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_global_connections</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="n">recurse</span><span class="p">)</span>

        <span class="c1"># Compute global_abs_in2out by first adding this group&#39;s contributions,</span>
        <span class="c1"># then adding contributions from systems above/below, then allgathering.</span>
        <span class="n">conn_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">iteritems</span><span class="p">(</span><span class="n">global_abs_in2out</span><span class="p">))</span>
        <span class="n">conn_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">iteritems</span><span class="p">(</span><span class="n">abs_in2out</span><span class="p">))</span>
        <span class="n">global_abs_in2out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abs_in2out</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
            <span class="n">global_abs_in2out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_conn_global_abs_in2out</span><span class="p">)</span>
            <span class="n">conn_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">iteritems</span><span class="p">(</span><span class="n">subsys</span><span class="o">.</span><span class="n">_conn_global_abs_in2out</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">global_abs_in2out</span><span class="p">):</span>
            <span class="n">dupes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">tgt</span> <span class="k">for</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">conn_list</span><span class="p">))</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">dup_info</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">conn_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">dup</span> <span class="ow">in</span> <span class="n">dupes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">tgt</span> <span class="o">==</span> <span class="n">dup</span><span class="p">:</span>
                        <span class="n">dup_info</span><span class="p">[</span><span class="n">tgt</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
            <span class="n">dup_info</span> <span class="o">=</span> <span class="p">[(</span><span class="n">n</span><span class="p">,</span> <span class="n">srcs</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">srcs</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">dup_info</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">srcs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dup_info</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">srcs</span><span class="p">))</span> <span class="k">for</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">srcs</span> <span class="ow">in</span> <span class="n">dup_info</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;The following inputs have multiple connections: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                   <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="c1"># If running in parallel, allgather</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="n">global_abs_in2out</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">raw</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">gathered</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">allgather</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">myproc_global_abs_in2out</span> <span class="ow">in</span> <span class="n">gathered</span><span class="p">:</span>
                <span class="n">global_abs_in2out</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">myproc_global_abs_in2out</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_relevance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the relevance dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mode : str</span>
<span class="sd">            Derivative direction, either &#39;fwd&#39; or &#39;rev&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            The relevance dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">desvars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_design_vars</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_sizes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_responses</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">get_sizes</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">get_relevant_vars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conn_global_abs_in2out</span><span class="p">,</span> <span class="n">desvars</span><span class="p">,</span> <span class="n">responses</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute dict of all implicit and explicit connections owned by this system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_connections</span><span class="p">()</span>
        <span class="n">abs_in2out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn_abs_in2out</span>

        <span class="n">global_abs_in2out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn_global_abs_in2out</span>
        <span class="n">pathname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span>

        <span class="c1"># Recursion</span>
        <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_connections</span><span class="p">(</span><span class="n">recurse</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pathname</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">path_len</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">path_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pathname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">allprocs_abs2meta_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs2meta</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
        <span class="n">allprocs_abs2meta_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs2meta</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>

        <span class="c1"># Check input/output units here, and set _has_input_scaling</span>
        <span class="c1"># to True for this Group if units are defined and different, or if</span>
        <span class="c1"># ref or ref0 are defined for the output.</span>
        <span class="k">for</span> <span class="n">abs_in</span><span class="p">,</span> <span class="n">abs_out</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">global_abs_in2out</span><span class="p">):</span>
            <span class="c1"># First, check that this system owns both the input and output.</span>
            <span class="k">if</span> <span class="n">abs_in</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">pathname</span><span class="p">)]</span> <span class="o">==</span> <span class="n">pathname</span> <span class="ow">and</span> <span class="n">abs_out</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">pathname</span><span class="p">)]</span> <span class="o">==</span> <span class="n">pathname</span><span class="p">:</span>
                <span class="c1"># Second, check that they are in different subsystems of this system.</span>
                <span class="n">out_subsys</span> <span class="o">=</span> <span class="n">abs_out</span><span class="p">[</span><span class="n">path_len</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">in_subsys</span> <span class="o">=</span> <span class="n">abs_in</span><span class="p">[</span><span class="n">path_len</span><span class="p">:]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">out_subsys</span> <span class="o">!=</span> <span class="n">in_subsys</span><span class="p">:</span>
                    <span class="n">abs_in2out</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">abs_out</span>

            <span class="c1"># if connected output has scaling then we need input scaling</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_input_scaling</span><span class="p">:</span>
                <span class="n">out_units</span> <span class="o">=</span> <span class="n">allprocs_abs2meta_out</span><span class="p">[</span><span class="n">abs_out</span><span class="p">][</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>
                <span class="n">in_units</span> <span class="o">=</span> <span class="n">allprocs_abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>

                <span class="c1"># if units are defined and different, we need input scaling.</span>
                <span class="n">needs_input_scaling</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_units</span> <span class="ow">and</span> <span class="n">out_units</span> <span class="ow">and</span> <span class="n">in_units</span> <span class="o">!=</span> <span class="n">out_units</span><span class="p">)</span>

                <span class="c1"># we also need it if a connected output has any scaling.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">needs_input_scaling</span><span class="p">:</span>
                    <span class="n">out_meta</span> <span class="o">=</span> <span class="n">allprocs_abs2meta_out</span><span class="p">[</span><span class="n">abs_out</span><span class="p">]</span>

                    <span class="n">ref</span> <span class="o">=</span> <span class="n">out_meta</span><span class="p">[</span><span class="s1">&#39;ref&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">ref</span><span class="p">):</span>
                        <span class="n">needs_input_scaling</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">!=</span> <span class="mf">1.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">needs_input_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ref</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">)</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">needs_input_scaling</span><span class="p">:</span>
                        <span class="n">ref0</span> <span class="o">=</span> <span class="n">out_meta</span><span class="p">[</span><span class="s1">&#39;ref0&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">ref0</span><span class="p">):</span>
                            <span class="n">needs_input_scaling</span> <span class="o">=</span> <span class="n">ref0</span> <span class="o">!=</span> <span class="mf">0.0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">needs_input_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ref0</span><span class="p">)</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">needs_input_scaling</span><span class="p">:</span>
                            <span class="n">res_ref</span> <span class="o">=</span> <span class="n">out_meta</span><span class="p">[</span><span class="s1">&#39;res_ref&#39;</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">res_ref</span><span class="p">):</span>
                                <span class="n">needs_input_scaling</span> <span class="o">=</span> <span class="n">res_ref</span> <span class="o">!=</span> <span class="mf">1.0</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">needs_input_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">res_ref</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_has_input_scaling</span> <span class="o">=</span> <span class="n">needs_input_scaling</span>

        <span class="c1"># Now that both implicit &amp; explicit connections have been added,</span>
        <span class="c1"># check unit/shape compatibility, but only for connections that are</span>
        <span class="c1"># either owned by (implicit) or declared by (explicit) this Group.</span>
        <span class="c1"># This way, we don&#39;t repeat the error checking in multiple groups.</span>
        <span class="n">abs2meta_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs2meta</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
        <span class="n">abs2meta_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs2meta</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">abs_in</span><span class="p">,</span> <span class="n">abs_out</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">abs_in2out</span><span class="p">):</span>
            <span class="c1"># check unit compatibility</span>
            <span class="n">out_units</span> <span class="o">=</span> <span class="n">allprocs_abs2meta_out</span><span class="p">[</span><span class="n">abs_out</span><span class="p">][</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>
            <span class="n">in_units</span> <span class="o">=</span> <span class="n">allprocs_abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;units&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">out_units</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">in_units</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Output &#39;</span><span class="si">%s</span><span class="s2">&#39; with units of &#39;</span><span class="si">%s</span><span class="s2">&#39; is &quot;</span>
                                  <span class="s2">&quot;connected to input &#39;</span><span class="si">%s</span><span class="s2">&#39; which has no&quot;</span>
                                  <span class="s2">&quot; units.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">abs_out</span><span class="p">,</span> <span class="n">out_units</span><span class="p">,</span> <span class="n">abs_in</span><span class="p">))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">is_compatible</span><span class="p">(</span><span class="n">in_units</span><span class="p">,</span> <span class="n">out_units</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Output units of &#39;</span><span class="si">%s</span><span class="s2">&#39; for &#39;</span><span class="si">%s</span><span class="s2">&#39; are&quot;</span>
                                       <span class="s2">&quot; incompatible with input units of &quot;</span>
                                       <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; for &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span>
                                       <span class="p">(</span><span class="n">out_units</span><span class="p">,</span> <span class="n">abs_out</span><span class="p">,</span> <span class="n">in_units</span><span class="p">,</span> <span class="n">abs_in</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">in_units</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Input &#39;</span><span class="si">%s</span><span class="s2">&#39; with units of &#39;</span><span class="si">%s</span><span class="s2">&#39; is &quot;</span>
                              <span class="s2">&quot;connected to output &#39;</span><span class="si">%s</span><span class="s2">&#39; which has &quot;</span>
                              <span class="s2">&quot;no units.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">abs_in</span><span class="p">,</span> <span class="n">in_units</span><span class="p">,</span> <span class="n">abs_out</span><span class="p">))</span>

            <span class="c1"># check shape compatibility</span>
            <span class="k">if</span> <span class="n">abs_in</span> <span class="ow">in</span> <span class="n">abs2meta_in</span> <span class="ow">and</span> <span class="n">abs_out</span> <span class="ow">in</span> <span class="n">abs2meta_out</span><span class="p">:</span>
                <span class="c1"># get output shape from allprocs meta dict, since it may</span>
                <span class="c1"># be distributed (we want global shape)</span>
                <span class="n">out_shape</span> <span class="o">=</span> <span class="n">allprocs_abs2meta_out</span><span class="p">[</span><span class="n">abs_out</span><span class="p">][</span><span class="s1">&#39;global_shape&#39;</span><span class="p">]</span>
                <span class="c1"># get input shape and src_indices from the local meta dict</span>
                <span class="c1"># (input is always local)</span>
                <span class="n">in_shape</span> <span class="o">=</span> <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
                <span class="n">src_indices</span> <span class="o">=</span> <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;src_indices&#39;</span><span class="p">]</span>
                <span class="n">flat</span> <span class="o">=</span> <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;flat_src_indices&#39;</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">src_indices</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">out_shape</span> <span class="o">!=</span> <span class="n">in_shape</span><span class="p">:</span>
                    <span class="c1"># out_shape != in_shape is allowed if</span>
                    <span class="c1"># there&#39;s no ambiguity in storage order</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span> <span class="o">==</span> <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
                            <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">in_shape</span><span class="p">)):</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The source and target shapes do not match or are ambiguous&quot;</span>
                               <span class="s2">&quot; for the connection &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;. Expected </span><span class="si">%s</span><span class="s2"> but got </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">abs_out</span><span class="p">,</span> <span class="n">abs_in</span><span class="p">,</span>
                                                <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">in_shape</span><span class="p">]),</span>
                                                <span class="nb">tuple</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">out_shape</span><span class="p">])))</span>

                <span class="k">if</span> <span class="n">src_indices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">src_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>

                    <span class="c1"># initial dimensions of indices shape must be same shape as target</span>
                    <span class="k">for</span> <span class="n">idx_d</span><span class="p">,</span> <span class="n">inp_d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">src_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">in_shape</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">idx_d</span> <span class="o">!=</span> <span class="n">inp_d</span><span class="p">:</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The source indices </span><span class="si">%s</span><span class="s2"> do not specify a &quot;</span>
                                   <span class="s2">&quot;valid shape for the connection &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                                   <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;. The target shape is &quot;</span>
                                   <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> but indices are </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                                                    <span class="n">abs_out</span><span class="p">,</span> <span class="n">abs_in</span><span class="p">,</span>
                                                    <span class="n">in_shape</span><span class="p">,</span> <span class="n">src_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

                    <span class="c1"># any remaining dimension of indices must match shape of source</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">src_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_shape</span><span class="p">):</span>
                        <span class="n">source_dimensions</span> <span class="o">=</span> <span class="n">src_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">in_shape</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="n">source_dimensions</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_shape</span><span class="p">):</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The source indices </span><span class="si">%s</span><span class="s2"> do not specify a &quot;</span>
                                   <span class="s2">&quot;valid shape for the connection &#39;</span><span class="si">%s</span><span class="s2">&#39; to &quot;</span>
                                   <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;. The source has </span><span class="si">%d</span><span class="s2"> &quot;</span>
                                   <span class="s2">&quot;dimensions but the indices expect </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span>
                                                    <span class="n">abs_out</span><span class="p">,</span> <span class="n">abs_in</span><span class="p">,</span>
                                                    <span class="nb">len</span><span class="p">(</span><span class="n">out_shape</span><span class="p">),</span> <span class="n">source_dimensions</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">source_dimensions</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="c1"># check all indices are in range of the source dimensions</span>
                    <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                        <span class="n">out_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)</span>
                        <span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>
                        <span class="n">mn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">mx</span> <span class="o">&gt;=</span> <span class="n">out_size</span><span class="p">:</span>
                            <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">mx</span>
                        <span class="k">elif</span> <span class="n">mn</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">out_size</span><span class="p">:</span>
                            <span class="n">bad_idx</span> <span class="o">=</span> <span class="n">mn</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bad_idx</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">if</span> <span class="n">bad_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The source indices do not specify &quot;</span>
                                   <span class="s2">&quot;a valid index for the connection &quot;</span>
                                   <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;. Index &quot;</span>
                                   <span class="s2">&quot;&#39;</span><span class="si">%d</span><span class="s2">&#39; is out of range for a flat source &quot;</span>
                                   <span class="s2">&quot;of size </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">)</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">abs_out</span><span class="p">,</span> <span class="n">abs_in</span><span class="p">,</span>
                                             <span class="n">bad_idx</span><span class="p">,</span> <span class="n">out_size</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">src_indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;src_indices&#39;</span><span class="p">]</span> <span class="o">=</span> \
                                <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">][</span><span class="s1">&#39;src_indices&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">source_dimensions</span><span class="p">):</span>
                            <span class="c1"># when running under MPI, there is a value for each proc</span>
                            <span class="n">d_size</span> <span class="o">=</span> <span class="n">out_shape</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">src_indices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">d_size</span><span class="p">:</span>
                                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The source indices do not specify &quot;</span>
                                           <span class="s2">&quot;a valid index for the connection &quot;</span>
                                           <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;. Index &quot;</span>
                                           <span class="s2">&quot;&#39;</span><span class="si">%d</span><span class="s2">&#39; is out of range for source &quot;</span>
                                           <span class="s2">&quot;dimension of size </span><span class="si">%d</span><span class="s2">.&quot;</span><span class="p">)</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">abs_out</span><span class="p">,</span> <span class="n">abs_in</span><span class="p">,</span>
                                                     <span class="n">i</span><span class="p">,</span> <span class="n">d_size</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_setup_global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext_num_vars</span><span class="p">,</span> <span class="n">ext_num_vars_byset</span><span class="p">,</span> <span class="n">ext_sizes</span><span class="p">,</span> <span class="n">ext_sizes_byset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute total number and total size of variables in systems before / after this system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ext_num_vars : {&#39;input&#39;: (int, int), &#39;output&#39;: (int, int)}</span>
<span class="sd">            Total number of allprocs variables in system before/after this one.</span>
<span class="sd">        ext_num_vars_byset : {&#39;input&#39;: dict of (int, int), &#39;output&#39;: dict of (int, int)}</span>
<span class="sd">            Same as above, but by var_set name.</span>
<span class="sd">        ext_sizes : {&#39;input&#39;: (int, int), &#39;output&#39;: (int, int)}</span>
<span class="sd">            Total size of allprocs variables in system before/after this one.</span>
<span class="sd">        ext_sizes_byset : {&#39;input&#39;: dict of (int, int), &#39;output&#39;: dict of (int, int)}</span>
<span class="sd">            Same as above, but by var_set name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_global</span><span class="p">(</span>
            <span class="n">ext_num_vars</span><span class="p">,</span> <span class="n">ext_num_vars_byset</span><span class="p">,</span> <span class="n">ext_sizes</span><span class="p">,</span> <span class="n">ext_sizes_byset</span><span class="p">)</span>

        <span class="n">iproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span>

        <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
            <span class="n">sub_ext_num_vars</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">sub_ext_sizes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">sub_ext_num_vars_byset</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">sub_ext_sizes_byset</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_lin_rel_vec_name_list</span><span class="p">:</span>
                <span class="n">subsystems_var_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_var_range</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>
                <span class="n">subsystems_var_range_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_var_range_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>
                <span class="n">sizes_byset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span>

                <span class="n">sub_ext_num_vars</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">sub_ext_sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">sub_ext_num_vars_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">sub_ext_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                    <span class="n">num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span>
                    <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="n">subsystems_var_range</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                    <span class="n">size1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:</span><span class="n">idx1</span><span class="p">])</span>
                    <span class="n">size2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">iproc</span><span class="p">,</span> <span class="n">idx2</span><span class="p">:])</span>

                    <span class="n">sub_ext_num_vars</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">ext_num_vars</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">,</span>
                        <span class="n">ext_num_vars</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="n">idx2</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">sub_ext_sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">ext_sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">size1</span><span class="p">,</span>
                        <span class="n">ext_sizes</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">size2</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="n">sub_ext_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="n">sub_ext_num_vars_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">set_name</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">]):</span>
                        <span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span> <span class="o">=</span> <span class="n">subsystems_var_range_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="n">subsys</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                        <span class="n">size1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:</span><span class="n">idx1</span><span class="p">])</span>
                        <span class="n">size2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes_byset</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="n">iproc</span><span class="p">,</span> <span class="n">idx2</span><span class="p">:])</span>

                        <span class="n">sub_ext_num_vars_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">ext_num_vars_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">idx1</span><span class="p">,</span>
                            <span class="n">ext_num_vars_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">num</span> <span class="o">-</span> <span class="n">idx2</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">sub_ext_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                            <span class="n">ext_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">size1</span><span class="p">,</span>
                            <span class="n">ext_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="n">type_</span><span class="p">][</span><span class="n">set_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">size2</span><span class="p">,</span>
                        <span class="p">)</span>

            <span class="n">sub_ext_num_vars</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_ext_num_vars</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>
            <span class="n">sub_ext_sizes</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_ext_sizes</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>
            <span class="n">sub_ext_num_vars_byset</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_ext_num_vars_byset</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>
            <span class="n">sub_ext_sizes_byset</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_ext_sizes_byset</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>

            <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_global</span><span class="p">(</span>
                <span class="n">sub_ext_num_vars</span><span class="p">,</span> <span class="n">sub_ext_num_vars_byset</span><span class="p">,</span>
                <span class="n">sub_ext_sizes</span><span class="p">,</span> <span class="n">sub_ext_sizes_byset</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_transfers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute all transfers that are owned by this system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_transfers</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">indices_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">indices_list</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="nb">int</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">recurse</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_setup_transfers</span><span class="p">(</span><span class="n">recurse</span><span class="p">)</span>

        <span class="c1"># Pre-compute map from abs_names to the index of the containing subsystem</span>
        <span class="n">abs2isub</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="p">{},</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="p">{}}</span>
        <span class="k">for</span> <span class="n">subsys</span><span class="p">,</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc_inds</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">abs_name</span> <span class="ow">in</span> <span class="n">subsys</span><span class="o">.</span><span class="n">_var_allprocs_abs_names</span><span class="p">[</span><span class="n">type_</span><span class="p">]:</span>
                    <span class="n">abs2isub</span><span class="p">[</span><span class="n">type_</span><span class="p">][</span><span class="n">abs_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">isub</span>

        <span class="n">abs2meta_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_abs2meta</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
        <span class="n">allprocs_abs2meta_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs2meta</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>

        <span class="n">transfers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transfers</span>
        <span class="n">vectors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_vectors</span>
        <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lin_rel_vec_name_list</span><span class="p">:</span>
            <span class="n">relvars</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_relevant</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;@all&#39;</span><span class="p">]</span>

            <span class="c1"># Initialize empty lists for the transfer indices</span>
            <span class="n">nsub_allprocs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">)</span>
            <span class="n">xfer_in</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">xfer_out</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">fwd_xfer_in</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">)]</span>
            <span class="n">fwd_xfer_out</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">)]</span>
            <span class="n">rev_xfer_in</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">)]</span>
            <span class="n">rev_xfer_out</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">set_name_in</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">set_name_out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">set_name_in</span><span class="p">,</span> <span class="n">set_name_out</span><span class="p">)</span>
                    <span class="n">xfer_in</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">xfer_out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">):</span>
                        <span class="n">fwd_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">fwd_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">rev_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">rev_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">allprocs_abs2idx_byset_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs2idx_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
            <span class="n">allprocs_abs2idx_byset_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_abs2idx_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>
            <span class="n">sizes_byset_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]</span>
            <span class="n">sizes_byset_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_sizes_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>

            <span class="c1"># Loop through all explicit / implicit connections owned by this system</span>
            <span class="k">for</span> <span class="n">abs_in</span><span class="p">,</span> <span class="n">abs_out</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_conn_abs_in2out</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">abs_out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">relvars</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>

                <span class="c1"># Only continue if the input exists on this processor</span>
                <span class="k">if</span> <span class="n">abs_in</span> <span class="ow">in</span> <span class="n">abs2meta_in</span> <span class="ow">and</span> <span class="n">abs_in</span> <span class="ow">in</span> <span class="n">relvars</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]:</span>

                    <span class="c1"># Get meta</span>
                    <span class="n">meta_in</span> <span class="o">=</span> <span class="n">abs2meta_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]</span>
                    <span class="n">meta_out</span> <span class="o">=</span> <span class="n">allprocs_abs2meta_out</span><span class="p">[</span><span class="n">abs_out</span><span class="p">]</span>

                    <span class="c1"># Get varset info</span>
                    <span class="n">set_name_in</span> <span class="o">=</span> <span class="n">meta_in</span><span class="p">[</span><span class="s1">&#39;var_set&#39;</span><span class="p">]</span>
                    <span class="n">set_name_out</span> <span class="o">=</span> <span class="n">meta_out</span><span class="p">[</span><span class="s1">&#39;var_set&#39;</span><span class="p">]</span>
                    <span class="n">idx_byset_in</span> <span class="o">=</span> <span class="n">allprocs_abs2idx_byset_in</span><span class="p">[</span><span class="n">abs_in</span><span class="p">]</span>
                    <span class="n">idx_byset_out</span> <span class="o">=</span> <span class="n">allprocs_abs2idx_byset_out</span><span class="p">[</span><span class="n">abs_out</span><span class="p">]</span>

                    <span class="c1"># Get the sizes (byset) array</span>
                    <span class="n">sizes_in</span> <span class="o">=</span> <span class="n">sizes_byset_in</span><span class="p">[</span><span class="n">set_name_in</span><span class="p">]</span>
                    <span class="n">sizes_out</span> <span class="o">=</span> <span class="n">sizes_byset_out</span><span class="p">[</span><span class="n">set_name_out</span><span class="p">]</span>

                    <span class="c1"># Read in and process src_indices</span>
                    <span class="n">shape_in</span> <span class="o">=</span> <span class="n">meta_in</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
                    <span class="n">shape_out</span> <span class="o">=</span> <span class="n">meta_out</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
                    <span class="n">global_shape_out</span> <span class="o">=</span> <span class="n">meta_out</span><span class="p">[</span><span class="s1">&#39;global_shape&#39;</span><span class="p">]</span>
                    <span class="n">global_size_out</span> <span class="o">=</span> <span class="n">meta_out</span><span class="p">[</span><span class="s1">&#39;global_size&#39;</span><span class="p">]</span>
                    <span class="n">src_indices</span> <span class="o">=</span> <span class="n">meta_in</span><span class="p">[</span><span class="s1">&#39;src_indices&#39;</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">src_indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">src_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">meta_in</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">src_indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">src_indices</span> <span class="o">=</span> <span class="n">convert_neg</span><span class="p">(</span><span class="n">src_indices</span><span class="p">,</span> <span class="n">global_size_out</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape_out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">shape_in</span> <span class="o">==</span> <span class="n">src_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                            <span class="n">src_indices</span> <span class="o">=</span> <span class="n">src_indices</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                            <span class="n">src_indices</span> <span class="o">=</span> <span class="n">convert_neg</span><span class="p">(</span><span class="n">src_indices</span><span class="p">,</span> <span class="n">global_size_out</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># TODO: this duplicates code found</span>
                            <span class="c1"># in System._setup_scaling.</span>
                            <span class="n">entries</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">shape_in</span><span class="p">]</span>
                            <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">src_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">entries</span><span class="p">))</span>
                            <span class="n">dimidxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_neg</span><span class="p">(</span><span class="n">cols</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">global_shape_out</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                            <span class="n">src_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">dimidxs</span><span class="p">,</span> <span class="n">global_shape_out</span><span class="p">)</span>

                    <span class="c1"># 1. Compute the output indices</span>
                    <span class="n">output_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">src_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
                    <span class="n">ind1</span> <span class="o">=</span> <span class="n">ind2</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">iproc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                        <span class="n">ind2</span> <span class="o">+=</span> <span class="n">sizes_out</span><span class="p">[</span><span class="n">iproc</span><span class="p">,</span> <span class="n">idx_byset_out</span><span class="p">]</span>

                        <span class="c1"># The part of src on iproc</span>
                        <span class="n">on_iproc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ind1</span> <span class="o">&lt;=</span> <span class="n">src_indices</span><span class="p">,</span> <span class="n">src_indices</span> <span class="o">&lt;</span> <span class="n">ind2</span><span class="p">)</span>

                        <span class="c1"># This converts from iproc-then-ivar to ivar-then-iproc ordering</span>
                        <span class="c1"># Subtract off part of previous procs</span>
                        <span class="c1"># Then add all variables on previous procs</span>
                        <span class="c1"># Then all previous variables on this proc</span>
                        <span class="c1"># - np.sum(out_sizes[:iproc, idx_byset_out])</span>
                        <span class="c1"># + np.sum(out_sizes[:iproc, :])</span>
                        <span class="c1"># + np.sum(out_sizes[iproc, :idx_byset_out])</span>
                        <span class="c1"># + inds</span>
                        <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">ind1</span>
                        <span class="n">offset</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes_out</span><span class="p">[:</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:])</span>
                        <span class="n">offset</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes_out</span><span class="p">[</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:</span><span class="n">idx_byset_out</span><span class="p">])</span>
                        <span class="n">output_inds</span><span class="p">[</span><span class="n">on_iproc</span><span class="p">]</span> <span class="o">=</span> <span class="n">src_indices</span><span class="p">[</span><span class="n">on_iproc</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>

                        <span class="n">ind1</span> <span class="o">+=</span> <span class="n">sizes_out</span><span class="p">[</span><span class="n">iproc</span><span class="p">,</span> <span class="n">idx_byset_out</span><span class="p">]</span>

                    <span class="c1"># 2. Compute the input indices</span>
                    <span class="n">iproc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span>
                    <span class="n">ind1</span> <span class="o">=</span> <span class="n">ind2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes_in</span><span class="p">[:</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:])</span>
                    <span class="n">ind1</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes_in</span><span class="p">[</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:</span><span class="n">idx_byset_in</span><span class="p">])</span>
                    <span class="n">ind2</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sizes_in</span><span class="p">[</span><span class="n">iproc</span><span class="p">,</span> <span class="p">:</span><span class="n">idx_byset_in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">input_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ind1</span><span class="p">,</span> <span class="n">ind2</span><span class="p">)</span>

                    <span class="c1"># Now the indices are ready - input_inds, output_inds</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">set_name_in</span><span class="p">,</span> <span class="n">set_name_out</span><span class="p">)</span>
                    <span class="n">xfer_in</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_inds</span><span class="p">)</span>
                    <span class="n">xfer_out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_inds</span><span class="p">)</span>

                    <span class="n">isub</span> <span class="o">=</span> <span class="n">abs2isub</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">][</span><span class="n">abs_in</span><span class="p">]</span>
                    <span class="n">fwd_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_inds</span><span class="p">)</span>
                    <span class="n">fwd_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_inds</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">abs_out</span> <span class="ow">in</span> <span class="n">abs2isub</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                        <span class="n">isub</span> <span class="o">=</span> <span class="n">abs2isub</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="n">abs_out</span><span class="p">]</span>
                        <span class="n">rev_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">input_inds</span><span class="p">)</span>
                        <span class="n">rev_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output_inds</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">set_name_in</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;input&#39;</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">set_name_out</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_num_var_byset</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">set_name_in</span><span class="p">,</span> <span class="n">set_name_out</span><span class="p">)</span>
                    <span class="n">xfer_in</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">xfer_in</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="n">xfer_out</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">xfer_out</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">):</span>
                        <span class="n">fwd_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">fwd_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
                        <span class="n">fwd_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">fwd_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
                        <span class="n">rev_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">rev_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>
                        <span class="n">rev_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">merge</span><span class="p">(</span><span class="n">rev_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">][</span><span class="n">key</span><span class="p">])</span>

            <span class="n">out_vec</span> <span class="o">=</span> <span class="n">vectors</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="n">vec_name</span><span class="p">]</span>
            <span class="n">transfer_class</span> <span class="o">=</span> <span class="n">out_vec</span><span class="o">.</span><span class="n">TRANSFER</span>

            <span class="n">transfers</span><span class="p">[</span><span class="n">vec_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">xfer_all</span> <span class="o">=</span> <span class="n">transfer_class</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">][</span><span class="n">vec_name</span><span class="p">],</span> <span class="n">out_vec</span><span class="p">,</span>
                                      <span class="n">xfer_in</span><span class="p">,</span> <span class="n">xfer_out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
            <span class="n">transfers</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfer_all</span>
            <span class="n">transfers</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;rev&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">xfer_all</span>
            <span class="k">for</span> <span class="n">isub</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub_allprocs</span><span class="p">):</span>
                <span class="n">transfers</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="n">isub</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_class</span><span class="p">(</span>
                    <span class="n">vectors</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">][</span><span class="n">vec_name</span><span class="p">],</span> <span class="n">vectors</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="n">vec_name</span><span class="p">],</span>
                    <span class="n">fwd_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">fwd_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>
                <span class="n">transfers</span><span class="p">[</span><span class="n">vec_name</span><span class="p">][</span><span class="s1">&#39;rev&#39;</span><span class="p">,</span> <span class="n">isub</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_class</span><span class="p">(</span>
                    <span class="n">vectors</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">][</span><span class="n">vec_name</span><span class="p">],</span> <span class="n">vectors</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="n">vec_name</span><span class="p">],</span>
                    <span class="n">rev_xfer_in</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="n">rev_xfer_out</span><span class="p">[</span><span class="n">isub</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>

        <span class="n">transfers</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfers</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">subsys</span><span class="p">,</span> <span class="n">promotes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a subsystem (deprecated version of &lt;Group.add_subsystem&gt;).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the subsystem being added</span>
<span class="sd">        subsys : System</span>
<span class="sd">            An instantiated, but not-yet-set up system object.</span>
<span class="sd">        promotes : iter of str, optional</span>
<span class="sd">            A list of variable names specifying which subsystem variables</span>
<span class="sd">            to &#39;promote&#39; up to this group. This is for backwards compatibility</span>
<span class="sd">            with older versions of OpenMDAO.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        System</span>
<span class="sd">            The System that was passed in.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warn_deprecation</span><span class="p">(</span><span class="s2">&quot;The &#39;add&#39; method provides backwards compatibility with &quot;</span>
                         <span class="s2">&quot;OpenMDAO &lt;= 1.x ; use &#39;add_subsystem&#39; instead.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_subsystem</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">subsys</span><span class="p">,</span> <span class="n">promotes</span><span class="o">=</span><span class="n">promotes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_subsystem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">subsys</span><span class="p">,</span> <span class="n">promotes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">promotes_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">promotes_outputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">min_procs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_procs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proc_weight</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a subsystem.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            Name of the subsystem being added</span>
<span class="sd">        subsys : &lt;System&gt;</span>
<span class="sd">            An instantiated, but not-yet-set up system object.</span>
<span class="sd">        promotes : iter of (str or tuple), optional</span>
<span class="sd">            A list of variable names specifying which subsystem variables</span>
<span class="sd">            to &#39;promote&#39; up to this group. If an entry is a tuple of the</span>
<span class="sd">            form (old_name, new_name), this will rename the variable in</span>
<span class="sd">            the parent group.</span>
<span class="sd">        promotes_inputs : iter of (str or tuple), optional</span>
<span class="sd">            A list of input variable names specifying which subsystem input</span>
<span class="sd">            variables to &#39;promote&#39; up to this group. If an entry is a tuple of</span>
<span class="sd">            the form (old_name, new_name), this will rename the variable in</span>
<span class="sd">            the parent group.</span>
<span class="sd">        promotes_outputs : iter of (str or tuple), optional</span>
<span class="sd">            A list of output variable names specifying which subsystem output</span>
<span class="sd">            variables to &#39;promote&#39; up to this group. If an entry is a tuple of</span>
<span class="sd">            the form (old_name, new_name), this will rename the variable in</span>
<span class="sd">            the parent group.</span>
<span class="sd">        min_procs : int</span>
<span class="sd">            Minimum number of MPI processes usable by the subsystem. Defaults to 1.</span>
<span class="sd">        max_procs : int or None</span>
<span class="sd">            Maximum number of MPI processes usable by the subsystem.  A value</span>
<span class="sd">            of None (the default) indicates there is no maximum limit.</span>
<span class="sd">        proc_weight : float</span>
<span class="sd">            Weight given to the subsystem when allocating available MPI processes</span>
<span class="sd">            to all subsystems.  Default is 1.0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        &lt;System&gt;</span>
<span class="sd">            the subsystem that was passed in. This is returned to</span>
<span class="sd">            enable users to instantiate and add a subsystem at the</span>
<span class="sd">            same time, and get the reference back.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_static_subsystems_allprocs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="n">sub</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Subsystem name &#39;</span><span class="si">%s</span><span class="s2">&#39; is already used.&quot;</span> <span class="o">%</span>
                                   <span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="n">System</span><span class="p">):</span>
            <span class="c1"># replacing a subsystem is ok (e.g. resetup) but no other attribute</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Group &#39;</span><span class="si">%s</span><span class="s2">&#39; already has an attribute &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span>
                               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

        <span class="n">match</span> <span class="o">=</span> <span class="n">namecheck_rgx</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span> <span class="o">!=</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid system name.&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

        <span class="n">subsys</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">promotes</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">promotes_inputs</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> \
           <span class="nb">isinstance</span><span class="p">(</span><span class="n">promotes_outputs</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: promotes&quot;</span>
                                   <span class="s2">&quot; must be an iterator of strings and/or tuples.&quot;</span> <span class="o">%</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">promotes</span><span class="p">:</span>
            <span class="n">subsys</span><span class="o">.</span><span class="n">_var_promotes</span><span class="p">[</span><span class="s1">&#39;any&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">promotes</span>
        <span class="k">if</span> <span class="n">promotes_inputs</span><span class="p">:</span>
            <span class="n">subsys</span><span class="o">.</span><span class="n">_var_promotes</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">promotes_inputs</span>
        <span class="k">if</span> <span class="n">promotes_outputs</span><span class="p">:</span>
            <span class="n">subsys</span><span class="o">.</span><span class="n">_var_promotes</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">promotes_outputs</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_mode</span><span class="p">:</span>
            <span class="n">subsystems_allprocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_subsystems_allprocs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subsystems_allprocs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span>

        <span class="n">subsystems_allprocs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">subsys</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">min_procs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">min_procs</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: min_procs must be an int &gt; 0 but (</span><span class="si">%s</span><span class="s2">) was given.&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">min_procs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">max_procs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_procs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="n">max_procs</span> <span class="o">&lt;</span> <span class="n">min_procs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: max_procs must be None or an int &gt;= min_procs but (</span><span class="si">%s</span><span class="s2">) was given.&quot;</span>
                            <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">max_procs</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">proc_weight</span><span class="p">,</span> <span class="n">Number</span><span class="p">)</span> <span class="ow">and</span> <span class="n">proc_weight</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: proc_weight must be a float &gt; 0. but (</span><span class="si">%s</span><span class="s2">) was given.&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">proc_weight</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_proc_info</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_procs</span><span class="p">,</span> <span class="n">max_procs</span><span class="p">,</span> <span class="n">proc_weight</span><span class="p">)</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">subsys</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">subsys</span>

    <span class="k">def</span> <span class="nf">connect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_name</span><span class="p">,</span> <span class="n">tgt_name</span><span class="p">,</span> <span class="n">src_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat_src_indices</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connect source src_name to target tgt_name in this namespace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        src_name : str</span>
<span class="sd">            name of the source variable to connect</span>
<span class="sd">        tgt_name : str or [str, ... ] or (str, ...)</span>
<span class="sd">            name of the target variable(s) to connect</span>
<span class="sd">        src_indices : int or list of ints or tuple of ints or int ndarray or Iterable or None</span>
<span class="sd">            The global indices of the source variable to transfer data from.</span>
<span class="sd">            The shapes of the target and src_indices must match, and form of the</span>
<span class="sd">            entries within is determined by the value of &#39;flat_src_indices&#39;.</span>
<span class="sd">        flat_src_indices : bool</span>
<span class="sd">            If True, each entry of src_indices is assumed to be an index into the</span>
<span class="sd">            flattened source.  Otherwise it must be a tuple or list of size equal</span>
<span class="sd">            to the number of dimensions of the source.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if src_indices argument is given, it should be valid</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src_indices</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tgt_name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">tgt_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">tgt_name</span><span class="p">]</span>
            <span class="n">tgt_name</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;src_indices must be an index array, did you mean&quot;</span>
                            <span class="s2">&quot; connect(&#39;</span><span class="si">%s</span><span class="s2">&#39;, </span><span class="si">%s</span><span class="s2">)?&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">tgt_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src_indices</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">src_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">src_indices</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">src_indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">src_indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;src_indices must contain integers, but src_indices for &quot;</span>
                                <span class="s2">&quot;connection from &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39; is </span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">tgt_name</span><span class="p">,</span> <span class="n">src_indices</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

        <span class="c1"># if multiple targets are given, recursively connect to each</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tgt_name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tgt_name</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">tgt_name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">src_indices</span><span class="p">,</span> <span class="n">flat_src_indices</span><span class="o">=</span><span class="n">flat_src_indices</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># target should not already be connected</span>
        <span class="k">for</span> <span class="n">manual_connections</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_manual_connections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_manual_connections</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">tgt_name</span> <span class="ow">in</span> <span class="n">manual_connections</span><span class="p">:</span>
                <span class="n">srcname</span> <span class="o">=</span> <span class="n">manual_connections</span><span class="p">[</span><span class="n">tgt_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Input &#39;</span><span class="si">%s</span><span class="s2">&#39; is already connected to &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="n">tgt_name</span><span class="p">,</span> <span class="n">srcname</span><span class="p">))</span>

        <span class="c1"># source and target should not be in the same system</span>
        <span class="k">if</span> <span class="n">src_name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">tgt_name</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Output and input are in the same System for &quot;</span> <span class="o">+</span>
                               <span class="s2">&quot;connection from &#39;</span><span class="si">%s</span><span class="s2">&#39; to &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">tgt_name</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_mode</span><span class="p">:</span>
            <span class="n">manual_connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_manual_connections</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">manual_connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_manual_connections</span>

        <span class="n">manual_connections</span><span class="p">[</span><span class="n">tgt_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">src_name</span><span class="p">,</span> <span class="n">src_indices</span><span class="p">,</span> <span class="n">flat_src_indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_order</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Specify a new execution order for this system.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_order : list of str</span>
<span class="sd">            List of system names in desired new execution order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the new_order is valid. It must contain all subsystems</span>
        <span class="c1"># in this model.</span>
        <span class="n">newset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_mode</span><span class="p">:</span>
            <span class="n">subsystems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_static_subsystems_allprocs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subsystems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span>
        <span class="n">olddict</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">subsystems</span><span class="p">}</span>
        <span class="n">oldset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">olddict</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">oldset</span> <span class="o">!=</span> <span class="n">newset</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="n">missing</span> <span class="o">=</span> <span class="n">oldset</span> <span class="o">-</span> <span class="n">newset</span>
            <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2"> expected in subsystem order and not found.&quot;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">missing</span><span class="p">)))</span>

            <span class="n">extra</span> <span class="o">=</span> <span class="n">newset</span> <span class="o">-</span> <span class="n">oldset</span>
            <span class="k">if</span> <span class="n">extra</span><span class="p">:</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: subsystem(s) </span><span class="si">%s</span><span class="s2"> found in subsystem order but don&#39;t exist.&quot;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">extra</span><span class="p">)))</span>

            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="c1"># Don&#39;t allow duplicates either.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">newset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_order</span><span class="p">):</span>
            <span class="n">dupes</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">new_order</span><span class="p">))</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: Duplicate name(s) found in subsystem order list: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dupes</span><span class="p">)))</span>

        <span class="n">subsystems</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">olddict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">new_order</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_subsystem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the system called &#39;name&#39; in the current namespace.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            name of the desired system in the current namespace.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        System or None</span>
<span class="sd">            System if found else None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">system</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">for</span> <span class="n">subname</span> <span class="ow">in</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">chain</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">_static_subsystems_allprocs</span><span class="p">,</span>
                             <span class="n">system</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">subname</span><span class="p">:</span>
                    <span class="n">system</span> <span class="o">=</span> <span class="n">sub</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">system</span>

    <span class="k">def</span> <span class="nf">_apply_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute residuals. The model is assumed to be in a scaled state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">else</span> <span class="s1">&#39;root&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transfer</span><span class="p">(</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">,</span> <span class="s1">&#39;fwd&#39;</span><span class="p">)</span>
        <span class="c1"># Apply recursion</span>
        <span class="k">with</span> <span class="n">Recording</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;._apply_nonlinear&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_count</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_apply_nonlinear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_solve_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute outputs. The model is assumed to be in a scaled state.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        boolean</span>
<span class="sd">            Failure flag; True if failed to converge, False is successful.</span>
<span class="sd">        float</span>
<span class="sd">            relative error.</span>
<span class="sd">        float</span>
<span class="sd">            absolute error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_solve_nonlinear</span><span class="p">()</span>

        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">else</span> <span class="s1">&#39;root&#39;</span>

        <span class="k">with</span> <span class="n">Recording</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;._solve_nonlinear&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_count</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_guess_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provide initial guess for states.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_guess</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">isub</span><span class="p">,</span> <span class="n">sub</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sub</span><span class="o">.</span><span class="n">_has_guess</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transfer</span><span class="p">(</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">,</span> <span class="s1">&#39;fwd&#39;</span><span class="p">,</span> <span class="n">isub</span><span class="p">)</span>
                    <span class="n">sub</span><span class="o">.</span><span class="n">_guess_nonlinear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_apply_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec_names</span><span class="p">,</span> <span class="n">rel_systems</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">scope_out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scope_in</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute jac-vec product. The model is assumed to be in a scaled state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vec_names : [str, ...]</span>
<span class="sd">            list of names of the right-hand-side vectors.</span>
<span class="sd">        rel_systems : set of str</span>
<span class="sd">            Set of names of relevant systems based on the current linear solve.</span>
<span class="sd">        mode : str</span>
<span class="sd">            &#39;fwd&#39; or &#39;rev&#39;.</span>
<span class="sd">        scope_out : set or None</span>
<span class="sd">            Set of absolute output names in the scope of this mat-vec product.</span>
<span class="sd">            If None, all are in the scope.</span>
<span class="sd">        scope_in : set or None</span>
<span class="sd">            Set of absolute input names in the scope of this mat-vec product.</span>
<span class="sd">            If None, all are in the scope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">else</span> <span class="s1">&#39;root&#39;</span>

        <span class="n">vec_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vec_names</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_vec_names</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">Recording</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;._apply_linear&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_count</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian_context</span><span class="p">()</span> <span class="k">as</span> <span class="n">J</span><span class="p">:</span>
                <span class="c1"># Use global Jacobian</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_assembled_jac</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views_assembled_jac</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_jac</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="n">vec_names</span><span class="p">:</span>
                        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matvec_context</span><span class="p">(</span><span class="n">vec_name</span><span class="p">,</span> <span class="n">scope_out</span><span class="p">,</span> <span class="n">scope_in</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span> <span class="k">as</span> <span class="n">vecs</span><span class="p">:</span>
                            <span class="n">d_inputs</span><span class="p">,</span> <span class="n">d_outputs</span><span class="p">,</span> <span class="n">d_residuals</span> <span class="o">=</span> <span class="n">vecs</span>
                            <span class="n">J</span><span class="o">.</span><span class="n">_apply</span><span class="p">(</span><span class="n">d_inputs</span><span class="p">,</span> <span class="n">d_outputs</span><span class="p">,</span> <span class="n">d_residuals</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                <span class="c1"># Apply recursion</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">rel_systems</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">irrelevant_subs</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span>
                                           <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">pathname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">rel_systems</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fwd&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="n">vec_names</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_transfer</span><span class="p">(</span><span class="n">vec_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">rel_systems</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">irrelevant_subs</span><span class="p">:</span>
                                <span class="c1"># zero out dvecs of irrelevant subsystems</span>
                                <span class="c1"># TODO: it&#39;s not completely clear that this is</span>
                                <span class="c1">#       necessary in fwd mode.  I wasn&#39;t able to</span>
                                <span class="c1">#       produce convergence failures during testing</span>
                                <span class="c1">#       in fwd mode.</span>
                                <span class="n">s</span><span class="o">.</span><span class="n">_vectors</span><span class="p">[</span><span class="s1">&#39;residual&#39;</span><span class="p">][</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_const</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

                    <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">rel_systems</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">subsys</span><span class="o">.</span><span class="n">pathname</span> <span class="ow">in</span> <span class="n">rel_systems</span><span class="p">:</span>
                            <span class="n">subsys</span><span class="o">.</span><span class="n">_apply_linear</span><span class="p">(</span><span class="n">vec_names</span><span class="p">,</span> <span class="n">rel_systems</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">scope_out</span><span class="p">,</span> <span class="n">scope_in</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;rev&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">vec_name</span> <span class="ow">in</span> <span class="n">vec_names</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_transfer</span><span class="p">(</span><span class="n">vec_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">rel_systems</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">irrelevant_subs</span><span class="p">:</span>
                                    <span class="c1"># zero out dvecs of irrelevant subsystems</span>
                                    <span class="n">s</span><span class="o">.</span><span class="n">_vectors</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">][</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">set_const</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_solve_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec_names</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rel_systems</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Apply inverse jac product. The model is assumed to be in a scaled state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vec_names : [str, ...]</span>
<span class="sd">            list of names of the right-hand-side vectors.</span>
<span class="sd">        mode : str</span>
<span class="sd">            &#39;fwd&#39; or &#39;rev&#39;.</span>
<span class="sd">        rel_systems : set of str</span>
<span class="sd">            Set of names of relevant systems based on the current linear solve.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        boolean</span>
<span class="sd">            Failure flag; True if failed to converge, False is successful.</span>
<span class="sd">        float</span>
<span class="sd">            relative error.</span>
<span class="sd">        float</span>
<span class="sd">            absolute error.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">else</span> <span class="s1">&#39;root&#39;</span>

        <span class="n">vec_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vec_names</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rel_vec_names</span><span class="p">]</span>

        <span class="k">with</span> <span class="n">Recording</span><span class="p">(</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;._solve_linear&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_count</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">vec_names</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rel_systems</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_linearize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">do_nl</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_ln</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute jacobian / factorization. The model is assumed to be in a scaled state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        do_nl : boolean</span>
<span class="sd">            Flag indicating if the nonlinear solver should be linearized.</span>
<span class="sd">        do_ln : boolean</span>
<span class="sd">            Flag indicating if the linear solver should be linearized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian_context</span><span class="p">()</span> <span class="k">as</span> <span class="n">J</span><span class="p">:</span>

            <span class="n">sub_do_nl</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_solver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_solver</span><span class="o">.</span><span class="n">_linearize_children</span><span class="p">())</span>
            <span class="n">sub_do_ln</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linear_solver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> \
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_linear_solver</span><span class="o">.</span><span class="n">_linearize_children</span><span class="p">())</span>

            <span class="k">for</span> <span class="n">subsys</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_myproc</span><span class="p">:</span>
                <span class="n">subsys</span><span class="o">.</span><span class="n">_linearize</span><span class="p">(</span><span class="n">do_nl</span><span class="o">=</span><span class="n">sub_do_nl</span><span class="p">,</span> <span class="n">do_ln</span><span class="o">=</span><span class="n">sub_do_ln</span><span class="p">)</span>

            <span class="c1"># Group finite difference</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_jac</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_unscaled_context</span><span class="p">(</span><span class="n">outputs</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span><span class="p">]):</span>
                    <span class="k">for</span> <span class="n">approximation</span> <span class="ow">in</span> <span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_approx_schemes</span><span class="p">):</span>
                        <span class="n">approximation</span><span class="o">.</span><span class="n">compute_approximations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">J</span><span class="p">,</span> <span class="n">deriv_type</span><span class="o">=</span><span class="s1">&#39;total&#39;</span><span class="p">)</span>

                <span class="n">J</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>

            <span class="c1"># Update jacobian</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_assembled_jac</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views_assembled_jac</span><span class="p">:</span>
                <span class="n">J</span><span class="o">.</span><span class="n">_update</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_solver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">do_nl</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nonlinear_solver</span><span class="o">.</span><span class="n">_linearize</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_linear_solver</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">do_ln</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_linear_solver</span><span class="o">.</span><span class="n">_linearize</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">approx_totals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;fd&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Approximate derivatives for a Group using the specified approximation method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            The type of approximation that should be used. Valid options include:</span>
<span class="sd">            &#39;fd&#39;: Finite Difference, &#39;cs&#39;: Complex Step</span>
<span class="sd">        **kwargs : dict</span>
<span class="sd">            Keyword arguments for controlling the behavior of the approximation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_approx_schemes</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="n">supported_methods</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fd&#39;</span><span class="p">:</span> <span class="n">FiniteDifference</span><span class="p">,</span>
                             <span class="s1">&#39;cs&#39;</span><span class="p">:</span> <span class="n">ComplexStep</span><span class="p">}</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">supported_methods</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;Method &quot;</span><span class="si">{}</span><span class="s1">&quot; is not supported, method must be one of </span><span class="si">{}</span><span class="s1">&#39;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">supported_methods</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approx_schemes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_approx_schemes</span><span class="p">[</span><span class="n">method</span><span class="p">]</span> <span class="o">=</span> <span class="n">supported_methods</span><span class="p">[</span><span class="n">method</span><span class="p">]()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_jac</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_jac_meta</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_jacobians</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">jacobian</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set and populate jacobians down through the system tree.</span>

<span class="sd">        In &lt;Group&gt;, we only need to prepare for Group finite difference. However, to be efficient,</span>
<span class="sd">        we need to find the minimum set of inputs and outputs to approximate.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        jacobian : &lt;AssembledJacobian&gt; or None</span>
<span class="sd">            The global jacobian to populate for this system.</span>
<span class="sd">        recurse : bool</span>
<span class="sd">            Whether to call this method in subsystems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian_changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Group finite difference or complex step.</span>
        <span class="c1"># TODO: Does this work under or over an AssembledJacobian (and does that make sense)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_jac</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_approx_schemes</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">approx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_approx_schemes</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
            <span class="n">pro2abs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_var_allprocs_prom2abs_list</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_of</span><span class="p">:</span>
                <span class="n">of</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_of</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">of</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">pro2abs</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_wrt</span><span class="p">:</span>
                <span class="n">candidate_wrt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_wrt</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">candidate_wrt</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">pro2abs</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

            <span class="kn">from</span> <span class="nn">openmdao.core.indepvarcomp</span> <span class="k">import</span> <span class="n">IndepVarComp</span>
            <span class="n">wrt</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">ivc</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">candidate_wrt</span><span class="p">:</span>
                <span class="n">src</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn_abs_in2out</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">src</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">wrt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

                <span class="c1"># Weed out inputs connected to anything inside our system unless the source is an</span>
                <span class="c1"># indepvarcomp.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">compname</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">comp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_subsystem</span><span class="p">(</span><span class="n">compname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">IndepVarComp</span><span class="p">):</span>
                        <span class="n">wrt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
                        <span class="n">ivc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>

            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">jacobian_context</span><span class="p">()</span> <span class="k">as</span> <span class="n">J</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">of</span><span class="p">,</span> <span class="n">wrt</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">of</span><span class="p">)):</span>
                    <span class="n">meta_changes</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_outputs</span><span class="o">.</span><span class="n">_views_flat</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">meta_changes</span><span class="p">[</span><span class="s1">&#39;rows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                        <span class="n">meta_changes</span><span class="p">[</span><span class="s1">&#39;cols&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
                        <span class="n">meta_changes</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

                    <span class="c1"># This suppports desvar and constraint indices.</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_of_idx</span><span class="p">:</span>
                        <span class="n">meta_changes</span><span class="p">[</span><span class="s1">&#39;idx_of&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_of_idx</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

                    <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_wrt_idx</span><span class="p">:</span>
                        <span class="n">meta_changes</span><span class="p">[</span><span class="s1">&#39;idx_wrt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_wrt_idx</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="n">meta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subjacs_info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">SUBJAC_META_DEFAULTS</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

                    <span class="c1"># A group under approximation needs all keys from below, so set dependent to</span>
                    <span class="c1"># True.</span>
                    <span class="c1"># TODO: Maybe just need a subset of keys (those that go to the boundaries.)</span>
                    <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dependent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                    <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">meta_changes</span><span class="p">)</span>
                    <span class="n">meta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_owns_approx_jac_meta</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_subjacs_info</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta</span>

                    <span class="c1"># Create Jacobian stub for every key pair</span>
                    <span class="n">J</span><span class="o">.</span><span class="n">_set_partials_meta</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span>

                    <span class="c1"># Create approximations, but only for the ones we need.</span>
                    <span class="k">if</span> <span class="n">meta</span><span class="p">[</span><span class="s1">&#39;dependent&#39;</span><span class="p">]:</span>

                        <span class="c1"># Skip indepvarcomp res wrt other srcs</span>
                        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">ivc</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Skip explicit res wrt outputs</span>
                        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">of</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ivc</span><span class="p">:</span>

                            <span class="c1"># Support for specifying a desvar as an obj/con.</span>
                            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wrt</span> <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                                <span class="k">continue</span>

                        <span class="n">approx</span><span class="o">.</span><span class="n">add_approximation</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">meta</span><span class="p">)</span>

            <span class="n">approx</span><span class="o">.</span><span class="n">_init_approximations</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian</span><span class="o">.</span><span class="n">_system</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jacobian</span><span class="o">.</span><span class="n">_initialize</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_setup_jacobians</span><span class="p">(</span><span class="n">jacobian</span><span class="p">,</span> <span class="n">recurse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">compute_sys_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comps_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a dependency graph for subsystems in this group.</span>

<span class="sd">        Variable connection information is stored in each edge of</span>
<span class="sd">        the system graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        comps_only : bool (False)</span>
<span class="sd">            If True, return a graph of all components within this group</span>
<span class="sd">            or any of its descendants. No sub-groups will be included. Otherwise,</span>
<span class="sd">            a graph containing only direct children (both Components and Groups)</span>
<span class="sd">            of this group will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DiGraph</span>
<span class="sd">            A directed graph containing names of subsystems and their connections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_srcs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_conn_global_abs_in2out</span>
        <span class="n">glen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pathname</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">))</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pathname</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>

        <span class="c1"># add all systems as nodes in the graph so they&#39;ll be there even if</span>
        <span class="c1"># unconnected.</span>
        <span class="k">if</span> <span class="n">comps_only</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">pathname</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">system_iter</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">typ</span><span class="o">=</span><span class="n">Component</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">pathname</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subsystems_allprocs</span><span class="p">)</span>

        <span class="n">edge_data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">in_abs</span><span class="p">,</span> <span class="n">src_abs</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">input_srcs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">src_abs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">comps_only</span><span class="p">:</span>
                    <span class="n">src</span> <span class="o">=</span> <span class="n">src_abs</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">tgt</span> <span class="o">=</span> <span class="n">in_abs</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">src</span> <span class="o">=</span> <span class="n">src_abs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="n">glen</span><span class="p">]</span>
                    <span class="n">tgt</span> <span class="o">=</span> <span class="n">in_abs</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="n">glen</span><span class="p">]</span>

                <span class="c1"># store var connection data in each system to system edge for later</span>
                <span class="c1"># use in relevance calculation.</span>
                <span class="n">edge_data</span><span class="p">[(</span><span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">)][</span><span class="n">src_abs</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">in_abs</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">:</span>
            <span class="n">src_sys</span><span class="p">,</span> <span class="n">tgt_sys</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src_sys</span><span class="p">,</span> <span class="n">tgt_sys</span><span class="p">,</span> <span class="n">conns</span><span class="o">=</span><span class="n">edge_data</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">graph</span>


<span class="k">def</span> <span class="nf">get_relevant_vars</span><span class="p">(</span><span class="n">connections</span><span class="p">,</span> <span class="n">desvars</span><span class="p">,</span> <span class="n">responses</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all relevant vars between desvars and responses.</span>

<span class="sd">    Both vars are assumed to be outputs (either design vars or responses).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    connections : dict</span>
<span class="sd">        Mapping of inputs and their connected sources.</span>
<span class="sd">    desvars : list of str</span>
<span class="sd">        Names of design variables.</span>
<span class="sd">    responses : list of str</span>
<span class="sd">        Names of response variables.</span>
<span class="sd">    mode : str</span>
<span class="sd">        Direction of derivatives, either &#39;fwd&#39; or &#39;rev&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        Dict of ({&#39;outputs&#39;: dep_outputs, &#39;inputs&#39;: dep_inputs, dep_systems)</span>
<span class="sd">        keyed by design vars and responses.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">relevant</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">fwd</span> <span class="o">=</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fwd&#39;</span>

    <span class="c1"># Create a hybrid graph with components and all connected vars.  If a var is connected,</span>
    <span class="c1"># also connect it to its corresponding component.</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">tgt</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">connections</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>

        <span class="n">src_sys</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src_sys</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>

        <span class="n">tgt_sys</span> <span class="o">=</span> <span class="n">tgt</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">tgt</span><span class="p">,</span> <span class="n">tgt_sys</span><span class="p">)</span>

        <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">tgt</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="n">desvars</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">dv</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
            <span class="n">system</span> <span class="o">=</span> <span class="n">dv</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">dv</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">responses</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">res</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="s1">&#39;out&#39;</span><span class="p">)</span>
            <span class="n">system</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">system</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span>
    <span class="n">grev</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">desvar</span> <span class="ow">in</span> <span class="n">desvars</span><span class="p">:</span>
        <span class="n">dv</span> <span class="o">=</span> <span class="p">(</span><span class="n">desvar</span><span class="p">,</span> <span class="s1">&#39;dv&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dv</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="n">cache</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_connected_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">desvar</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">response</span> <span class="ow">in</span> <span class="n">responses</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">response</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">res</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_connected_nodes</span><span class="p">(</span><span class="n">grev</span><span class="p">,</span> <span class="n">response</span><span class="p">))</span>

            <span class="n">common</span> <span class="o">=</span> <span class="n">cache</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cache</span><span class="p">[</span><span class="n">res</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">common</span><span class="p">:</span>
                <span class="n">input_deps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">output_deps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">sys_deps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">common</span><span class="p">:</span>
                    <span class="k">if</span> <span class="s1">&#39;type_&#39;</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="n">typ</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;type_&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">typ</span> <span class="o">==</span> <span class="s1">&#39;in&#39;</span><span class="p">:</span>  <span class="c1"># input var</span>
                            <span class="n">input_deps</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                            <span class="n">system</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">system</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys_deps</span><span class="p">:</span>
                                <span class="n">sys_deps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">all_ancestors</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># output var</span>
                            <span class="n">output_deps</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                            <span class="n">system</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">system</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sys_deps</span><span class="p">:</span>
                                <span class="n">sys_deps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">all_ancestors</span><span class="p">(</span><span class="n">system</span><span class="p">))</span>

            <span class="k">elif</span> <span class="n">desvar</span> <span class="o">==</span> <span class="n">response</span><span class="p">:</span>
                <span class="n">input_deps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">output_deps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">response</span><span class="p">])</span>
                <span class="n">sys_deps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_ancestors</span><span class="p">(</span><span class="n">desvar</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">common</span> <span class="ow">or</span> <span class="n">desvar</span> <span class="o">==</span> <span class="n">response</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fwd</span><span class="p">:</span>
                    <span class="n">relevant</span><span class="p">[</span><span class="n">desvar</span><span class="p">][</span><span class="n">response</span><span class="p">]</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="n">input_deps</span><span class="p">,</span>
                                                   <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">output_deps</span><span class="p">},</span> <span class="n">sys_deps</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># rev</span>
                    <span class="n">relevant</span><span class="p">[</span><span class="n">response</span><span class="p">][</span><span class="n">desvar</span><span class="p">]</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="n">input_deps</span><span class="p">,</span>
                                                   <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">output_deps</span><span class="p">},</span> <span class="n">sys_deps</span><span class="p">)</span>

                <span class="n">sys_deps</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>  <span class="c1"># top level Group is always relevant</span>

    <span class="k">if</span> <span class="n">fwd</span><span class="p">:</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="n">desvars</span><span class="p">,</span> <span class="n">responses</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">inputs</span><span class="p">,</span> <span class="n">outputs</span> <span class="o">=</span> <span class="n">responses</span><span class="p">,</span> <span class="n">desvars</span>

    <span class="c1"># now calculate dependencies between each VOI and all other VOIs of the</span>
    <span class="c1"># other type, e.g for each input VOI wrt all output VOIs.  This is only</span>
    <span class="c1"># done for design vars in fwd mode or responses in rev mode.</span>
    <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
        <span class="n">relinp</span> <span class="o">=</span> <span class="n">relevant</span><span class="p">[</span><span class="n">inp</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">relinp</span><span class="p">:</span>
            <span class="n">total_inps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">total_outs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">total_systems</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">relinp</span><span class="p">:</span>
                    <span class="n">dct</span><span class="p">,</span> <span class="n">systems</span> <span class="o">=</span> <span class="n">relinp</span><span class="p">[</span><span class="n">out</span><span class="p">]</span>
                    <span class="n">total_inps</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">&#39;input&#39;</span><span class="p">])</span>
                    <span class="n">total_outs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">dct</span><span class="p">[</span><span class="s1">&#39;output&#39;</span><span class="p">])</span>
                    <span class="n">total_systems</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">systems</span><span class="p">)</span>
            <span class="n">relinp</span><span class="p">[</span><span class="s1">&#39;@all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="n">total_inps</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">total_outs</span><span class="p">},</span>
                              <span class="n">total_systems</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">relinp</span><span class="p">[</span><span class="s1">&#39;@all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">({</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">(),</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="nb">set</span><span class="p">()},</span> <span class="nb">set</span><span class="p">())</span>

    <span class="n">relevant</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;@all&#39;</span><span class="p">:</span> <span class="p">({</span><span class="s1">&#39;input&#39;</span><span class="p">:</span> <span class="n">ContainsAll</span><span class="p">(),</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">ContainsAll</span><span class="p">()},</span>
                                   <span class="n">ContainsAll</span><span class="p">())}</span>
    <span class="n">relevant</span><span class="p">[</span><span class="s1">&#39;nonlinear&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">relevant</span><span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">relevant</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">OpenMDAO 2.1.0 Alpha documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2016, openmdao.org.
      Last updated on Feb 09, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>